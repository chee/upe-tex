------------------------------------page 201------------------------------------
This chapter concentrates on the lowest level of interaction with the UNIX
operating system --- the system calls. These are the entries to the kernel. They
are the facilities that the operating system provides; everything else is built
on top of them.

We will cover several major areas. First is the I/O system, the foundation
beneath library routines like fopen and putc. We'll talk more about the file
system as well, particularly directories and inodes. Next comes a discussion of
processes --- how to run programs from within a program. After that we will talk
about signals and interrupts: what happens when you push the DELETE key, and how
to handle that sensibly in a program.

As in Chapter 6, many of our examples are useful programs that were not part of
the 7th Edition. Even if they are not directly helpful to you, you should learn
something from reading them, and they might suggest similar tools that you could
build for your system.

Full details on the system calls in Section 2 of the UNIX Programmer's Manual;
this chapter describes that most important parts, but makes no pretense of
completeness.



7.1 Low-level I/O

The lowest level of I/O is a direct entry into the operating system. Your
program reads or writes files in chunks of any convenient size. The kernel
buffers your data into chunks that match the peripheral devices, and schedules
operations on the devices to optimize their performance over all users.


File descriptors

All input and output is done by reading or writing files, because all peripheral
devices, even your terminal, are files in the file system. This means that a
single interface handles all communication between a program and peripheral
devices.

In the most general case, before reading or writing a file, it is necessary to
inform the system of your intent to do so, a process called opening the file. If
you are going to write on a file, it may also be necessary to create it. The
system checks your right to do so (Does the file exist? Do you have permission
to access it?), and if all is well, returns a non-negative integer called a file
descriptor. Whenever I/O is to be done on the file, the file descriptor is used
instead of the name to identify the file. All information about an open file is
maintained by the system; your program refers to the file only by the file
descriptor. a FILE pointer as discussed in Chapter 6 points to a structure that
contains, among other things, the file descriptor; the macro fileno(fp) defined
in <stdio.h> returns the file descriptor.

There are special arrangements to make terminal input and output
convenient. When it is started by the shell, a program inherits three open
files, with file descriptor 0, 1, and 2, called the standard input, the standard
output, and the standard error. All of these are by default connected to the
terminal, so if a program only reads file descriptor 0 and writes file
descriptor 1 and 2, it can do I/O without having to open files. If the program
opens any other files, they will have file descriptors 3, 4, etc.

If I/O is redirected to or from files or pipes, the shell changes the default
assignments for file descriptor 0 and 1 from the terminal to the named
files. Normally file descriptor 2 remains attached to the terminal, so error
messages can go there. Shell incantations such as 2>filename and 2>&1 will cause
rearrangements of the defaults, but the file assignments are changed by the
shell, not by the program. (The program itself can rearrange these further if it
wishes, but this is rare.)


File I/O --- read and write

All input and output is done by two system calls, read and write, which are
accessed from C by functions of the same name. For both, the first argument is a
file descriptor. The second argument is an array of bytes that serves as the
data source of destination. The third argument is the number of bytes to be
transferred.

	int fd, n, nread, nwritten;
	char buf [SIZE];

	nread = read(fd, buf, n);
	nwritten = write (fd, buf, n);

Each call returns a count of the number of bytes transferred. On reading, the
number of bytes returned may be less than the number requested, because fewer
than n bytes remained to be read. (When the file is a terminal, read normally
reads only up to the next newline, which is usually less than what was
requested.) A return value of zero implies end of file, and -1 indicates an
error of some sort. For writing, the value returned is the number of bytes
actually written; an error has occurred if this isn't equal to the number
supposed to be written.

While the number of bytes to read or written is not restricted, the two most
common values are 1, which means one character at a time ("unbuffered"), and the
size of a block on a disc, most often 512 or 1024 bytes. (The parameter BUFSIZ
in <stdio.h> has this value.)

To illustrate, here is a program to copy its input to its output. Since the
input and output can be redirected to any file or device, it will actually copy
anything to anything: it's a bare-bones implementation of cat.

        /* cat:  minimal version */
        #define SIZE    512 /* arbitrary */

        main()
        {
            char buf[SIZE];
            int n;

            while ((n = read(0, buf, sizeof buf)) > 0)
                write(1, buf, n);
            exit(0);
        }

If the file size is not a multiple of SIZE, some read will return a smaller
number of bytes to be written by write; the next call to read after that will
return zero.

Reading and writing in chunks that match the disc will be most efficient, but
even character-at-a-time I/O is feasible for modest amounts of data, because the
kernel buffers your data; the main cost is the system calls. ed, for example,
uses one-byte reads to retrieve its standard input. We timed this version of cat
on a file of 54000 bytes, for six values of SIZE:

                           Time (user+system, sec.)
                   SIZE    PDP-11/40    VAX-11/750
                      1        271.0      188.8
                     10         29.9       19.3
                    100          3.8        2.6
                    512          1.3        1.0
                   1024          1.2        0.6
                   5120          1.0        0.6

The disc block size is 512 bytes on the PDP-11 system and 1024 on the VAX.

It is quite legal for several processes to be accessing the same file at the
same time; indeed, one process can be writing while another is reading. If this
isn't what you wanted, it can be disconcerting, but it's sometimes useful. Even
though one call to read returns 0 and thus signals end of file, if more data is
written on that file, a subsequent read will find more bytes available. This
observation is the basis of a program called readslow, which continues to read
input, regardless of whether it got an end of file or not. readslow is handy for
watching the process of a program:

        $ slowprog >temp &
        5213                                       Process-id
        $ readslow <temp | grep something

In other words, a slow program produces output in a file; readslow, perhaps in
collaboration with some other program, watches the data accumulate.

Structurally, readslow is identical to cat except that it loops instead of
quitting when it encounters the current end of the input. It has to use
low-level I/O because the standard library routines continue to report EOF after
the first end of file.

        /* readslow:  keep reading, waiting for more */
        #define SIZE    512 /* arbitrary */

        main()
        {
            char buf[SIZE];
            int n;

            for (;;) {
                while ((n = read(0, buf, sizeof buf)) > 0)
                    write(1, buf, n);
                sleep(10);
            }
        }

The function sleep causes the program to be suspended for the specified number
of seconds; it is described in sleep(3). We don't want readslow to bang away at
the file continuously looking for more data; that would be too costly in CPU
time. Thus this version of readslow copies its input up to the end of file,
sleeps a while, then tries again. If more data arrives while it is asleep, it
will be read by the next read.


Exercise 7-1. Add a -n argument to readslow so the default sleep time can be
changed to n seconds. Some systems provide an option -f ("forever") for tail
that combines the functions of tail with those of readslow. Comment on this
design.

Exercise 7-2. What happens to readslow if the file being read is truncated? How
would you fix it? Hint: read about fstat in Section 7.3.


File creation --- open, creat, close, unlink

Other than the default standard input, output and error files, you must
explicitly open files in order to read or write them. There are two system calls
for this, open and creat[1].

------------------------------------page 205------------------------------------
open is rather like fopen in the previous chapter, except that instead of
returning a file pointer, it returns a file descriptor, which is an int.

        char *name;
        int fd, rwmode;

        fd = open(name, rwmode);

As with fopen, the name argument is a character string containing the
filename. The access mode argument is different, however: rwmode is 0 for read,
1 for write, and 2 to open a file for both reading and writing. open returns -1
if any error occurs; otherwise it returns a valid file descriptor.

It is an error to try to open a file that does not exist. The system call creat
is provided to create new files, or to rewrite old ones.

        int perms;
        fd = creat(name, perms);

creat returns a file descriptor if it was able to create the file called name,
and -1 if not. If the file does not exist, creat creates it with permissions
specified by the perms argument. If the file already exists, creat will truncate
it to zero length; it is not an error to creat a file that already exists. (The
permissions will not be changed.) Regardless of perms, a created file is open
for writing.

As described in Chapter 2, there are nine bits of protection information
associated with a file, controlling read, write and execute permission, so a
three-digit octal number is convenient for specifying them. For example, 0755
specifies read, write and execute permission for the owner, and read and execute
permission for the group and everyone else. Don't forget the leading 0, which is
how octal numbers are specified in C.

To illustrate, here is a simplified version of cp. The main simplification is
that our version copies only one file, and does not permit the second argument
to be a directory. Another blemish is that our version does not preserve the
permissions of the source file; we will show how to remedy this later.

        /* cp:  minimal version */
        #include <stdio.h>
        #define PERMS 0644 /* RW for owner, R for group, others */
        char *progname;

        main(argc, argv)    /* cp: copy f1 to f2 */
            int argc;
            char *argv[];
        {
            int f1, f2, n;
            char buf[BUFSIZ];

            progname = argv[0];
            if (argc != 3)
                error("Usage: %s from to", progname);
            if ((f1 = open(argv[1], 0)) == -1)
                error("can't open %s", argv[1]);
            if ((f2 = creat(argv[2], PERMS)) == -1)
                error("can't create %s", argv[2]);

            while ((n = read(f1, buf, BUFSIZ)) > 0)
                if (write(f2, buf, n) != n)
                    error("write error", (char *) 0);
            exit(0);
        }

We will discuss error in the next sub-section.

There is a limit (typically about 20; look for NOFILE in <sys/param.h>) on the
number of files that a program may have open simultaneously. Accordingly, any
program that intends to process many files must be prepared to reuse file
descriptors. The system call close breaks the connection between a filename and
a file descriptor, freeing the file descriptor for use with some other file. The
termination of a program via exit or return from the main program closes all
open files.

The system call unlink removes a file from the file system.


Error processing --- errno

The system calls discussed in this section, and in fact all system calls, can
incur errors. Usually they indicate an error by returning a value of
-1. Sometimes it is nice to know what specific error occurred; for this purpose
all system calls, when appropriate, leave an error number in an external integer
called errno. (The meanings of the various error numbers are listed in the
introduction to Section 2 of the UNIX Programmer's Manual.) By using errono,
your program can, for example, determine whether an attempt to open a file
failed because it did not exist or because you lacked permission to read
it. There is also an array of character strings sys_errlist indexed by errno
that translates the numbers into a meaningful string. Our version of error uses
these data structures:

        error(s1, s2)   /* print error message and die */
            char *s1, *s2;
        {
            extern int errno, sys_nerr;
            extern char *sys_errlist[], *progname;

            if (progname)
                fprintf(stderr, "%s: ", progname);
            fprintf(stderr, s1, s2);
            if (errno > 0 && errno < sys_nerr)
                fprintf(stderr, " (%s)", sys_errlist[errno]);
            fprintf(stderr, "\n");
            exit(1);
        }

errno is initially zero, and should always be less than sys_nerr. It is not
reset to zero when things go well, however, so you must reset it after each
error if your program intends to continue.

Here is how error messages appear with this version of cp:

        $ cp foo bar
        cp: can't open foo (No such file or directory)
        $ date >foo; chmod 0 foo           Make an unreadable file
        $ cp too bar
        cp: can't open foo (Permission denied)
        $


Random access --- lseek

File I/O is normally sequential: each read or write takes place in the file
right after the previous one. When necessary, however, a file can be read or
written in an arbitrary order. The system call lseek provides a way to move
around in a file without actually reading or writing:

        int fd, origin;
        long offset, pos, lseek();

        pos = lseek(fd, offset, origin);

forces the current position in the file whose descriptor is fd to move to
position offset, which is taken relative to the location specified by
origin. Subsequent reading or writing will begin at that position. origin can be
0, 1, or 2 to specify that offset is to be measured from the beginning, from the
current position, or from the end of the file. The value returned is the new
absolute position, or -1 for an error. For example, to append to a file, seek to
the end before writing:

        lseek(fd, 0L, 2);

To get back to the beginning ("rewind"),

        lseek(fd, 0L, 0);

To determine the current position,

        pos = lseek(fd, 0L, 1);

Notice the 0L argument: the offset is a long integer. (The "l" in lseek stands
for 'long,' to distinguish it from the 6th Edition seek system call that used
short integers.)

With lseek, it is possible to treat files more or less like large arrays, at the
price of slower access. For example, the following function reads any number of
bytes from any place in a file.

        get(fd, pos, buf, n) /* read n bytes from position pos */
            int fd, n;
            long pos;
            char *buf;
        {
            if (lseek(fd, pos, 0) == -1)    /* get to pos */
                return -1;
            else
                return read(fd, buf, n);
        }

Exercise 7-3. Modify readslow to handle a filename argument if one is
present. Add the option -e:

        $ readslow -e

causes readslow to seek to the end of the input before beginning to read. What
does lseek do on a pipe?

Exercise 7-4. Rewrite efopen from Chapter 6 to call error.



7.2 File system: directories

The next topic is how to walk through the directory hierarchy. This doesn't
actually use any new system calls, just some old ones in a new context. We will
illustrate by writing a function called spname that tries to cope with
misspelled filenames. The function

        n = spname(name, newname);

searches for a file with a name "close enough" to name. If one is found, it is
copied into newname. The value n returned by spname is -1 if nothing close
enough was found, 0 if there was exact match, and 1 if a correction was made.

spname is a convenient addition to the p command: if you try to print a file but
misspell the name, p can ask if you really meant something else:

        $ p /urs/srx/ccmd/p/spnam.c          Horribly botched name
        "/usr/src/cmd/p/spname.c"? y         Suggested correction accepted
        /* spname: return correctly spelled filename */
        ...

As we will write it, spname will try to correct, in each component of the
filename, mismatches in which a single letter has been dropped or added, or a
single letter is wrong, or a pair of letters exchanged; all of these are
illustrated above. This is a boon for sloppy typists.

Before writing the code, a short review of file system structure is in order. A
directory is a file containing a list of file names and an indication of where
they are located. The "location" is actually an index into another table called
the inode table. The inode for a file is where all information about the file
except its name is kept. A directory entry thus consists of only two items, an
inode number and the file name. The precise specification can be found in the
file <sys/dir.h>:

        $ cat /usr/include/sys/dir.h
        #define DIRSIZ 14 /* max length of file name */

        struct direct /* structure of directory entry */
        {
            ino_t d_ino; /* indoe number */
            char d_name [DIRSIZ]; /* file name */
        };
        $

The "type" ino_t is a typedef describing the index into the inode table. It
happens to be unsigned short on PDP-11 and VAX version of the system, but this
is definitely not the sort of information to embed in a program: it might be
different on a different machine. Hence the typedef. A complete set of "system"
types is found in <sys/types.h>, which must be included before <sys/dir.h>.

The operation of spname is straightforward enough, although there are a lot of
boundary conditions to get right. Suppose the file name is /d1/d2/f. The basic
idea is to peel off the first component (/) then search that directory for a
name close to the next component (d1), then search that directory for something
near d2, and so on, until a match has been found for each component. If at any
stage there isn't a plausible candidate in the directory, the search is
abandoned.

We have divided the job into three functions. spname itself isolates the
components of the path and builds them into a "best match so far" filename.  It
calls mindist, which searches a given directory for the file that is closest to
the current guess, using a third function, spdist, to compute the distance
between two names.

        /* spname:  return correctly spelled filename */
        /*
         * spname(oldname, newname)  char *oldname, *newname;
         *  returns -1 if no reasonable match to oldname,
         *           0 if exact match,
         *           1 if corrected.
         *  stores corrected name in newname.
         */

        #include <sys/types.h>
        #include <sys/dir.h>

        spname(oldname, newname)
            char *oldname, *newname;
        {
            char *p, guess[DIRSIZ+1], best[DIRSIZ+1];
            char *new = newname, *old = oldname;

            for (;;) {
                while (*old == '/') /* skip slashes */
                    *new++ = *old++;
                *new = '\0';
                if (*old == '\0')   /* exact or corrected */
                    return strcmp(oldname,newname) != 0;
                p = guess;  /* copy next component into guess */
                for ( ; *old != '/' && *old != '\0'; old++)
                    if (p < guess+DIRSIZ)
                        *p++ = *old;
                *p = '\0';
                if (mindist(newname, guess, best) >= 3)
                    return -1;  /* hopeless */
                for (p = best; *new = *p++; ) /* add to end */
                    new++;                    /* of newname */
            }
        }

        mindist(dir, guess, best)   /* search dir for guess */
            char *dir, *guess, *best;
        {
            /* set best, return distance 0..3 */
            int d, nd, fd;
            struct {
                ino_t ino;
                char  name[DIRSIZ+1];   /* 1 more than in dir.h */
            } nbuf;

            nbuf.name[DIRSIZ] = '\0';   /* +1 for terminal '\0' */
            if (dir[0] == '\0')     /* current directory */
                dir = ".";
            d = 3;  /* minimum distance */
            if ((fd=open(dir, 0)) == -1)
                return d;
            while (read(fd,(char *) &nbuf,sizeof(struct direct)) > 0)
                if (nbuf.ino) {
                    nd = spdist(nbuf.name, guess);
                    if (nd <= d && nd != 3) {
                        strcpy(best, nbuf.name);
                        d = nd;
                        if (d == 0)     /* exact match */
                            break;
                    }
                }
            close(fd);
            return d;
        }

If the directory name given to mindist is empty, '.' searched. mindist reads on
directory entry at a time. Notice that the buffer for read is a structure, not
an array of characters. We use sizeof to compute the number of bytes, and coerce
the address to a character pointer.

If a slot in a directory is not currently in use (Because a file has been
removed), then the inode entry is zero, and this position is skipped. The
distance test is

        if (nd <= d...)

instead of

        if (nd < d...)

so that any other single character is a better match than '.', which is always
the first entry in a directory.

        /* spdist:  return distance between two names */
        /*
         *  very rough spelling metric:
         *  0 if the strings are identical
         *  1 if two chars are transposed
         *  2 if one char wrong, added or deleted
         *  3 otherwise
         */

        #define EQ(s,t) (strcmp(s,t) == 0)

        spdist(s, t)
            char *s, *t;
        {
            while (*s++ == *t)
                if (*t++ == '\0')
                    return 0;       /* exact match */
            if (*--s) {
                if (*t) {
                    if (s[1] && t[1] && *s == t[1]
                      && *t == s[1] && EQ(s+2, t+2))
                        return 1;   /* transposition */
                    if (EQ(s+1, t+1))
                        return 2;   /* 1 char mismatch */
                }
                if (EQ(s+1, t))
                    return 2;       /* extra character */
            }
            if (*t && EQ(s, t+1))
                return 2;           /* missing character */
            return 3;
        }

Once we have spname, integrating spelling correction into p is easy:

        /* p:  print input in chunks (version 4) */

        #include <stdio.h>
        #define PAGESIZE    22
        char    *progname;  /* program name for error message */

        main(argc, argv)
            int argc;
            char *argv[];
        {
            FILE *fp, *efopen();
            int i, pagesize = PAGESIZE;
            char *p, *getenv(), buf[BUFSIZ];

            progname = argv[0];
            if ((p=getenv("PAGESIZE")) != NULL)
                pagesize = atoi(p);
            if (argc > 1 && argv[1][0] == '-') {
                pagesize = atoi(&argv[1][1]);
                argc--;
                argv++;
            }
            if (argc == 1)
                print(stdin, pagesize);
            else
                for (i = 1; i < argc; i++)
                    switch (spname(argv[i], buf)) {
                    case -1:    /* no match possible */
                        fp = efopen(argv[i], "r");
                        break;
                    case 1:     /* corrected */
                        fprintf(stderr, "\"%s\"? ", buf);
                        if (ttyin() == 'n')
                            break;
                        argv[i] = buf;
                        /* fall through... */
                    case 0: /* exact match */
                        fp = efopen(argv[i], "r");
                        print(fp, pagesize);
                        fclose(fp);
                    }
            exit(0);
        }

Spelling correction is not something to be blindly applied to every program that
uses filenames. It works well with p because p is interactive, but it's not
suitable for programs that might not be interactive.

Exercise 7-5. How much can you improve on the heuristic for selecting the best
match in spname? For example, it is foolish to treat a regular file as if it
were directory; this can happen with the current version.

Exercise 7-6. The name tx matches whichever of tc happens to come last in the
directory, for any single character c. Can you invent a better distance measure?
Implement it and see how well it works with real users.

Exercise 7-7. mindist reads the directory one entry at a time. Does p run
perceptibly faster if directory reading is done in bigger chunks?

Exercise 7-8. Modify spname to return a name that is a prefix of the desired
name if no closer match can be found. How should ties be broken if there are
several names that all match the prefix?

Exercise 7-9. What other programs could profit form spname? Design a standalone
program that would apply correction to its arguments before passing them along
to another program, as in

        $ fix prog filenames...

Can you write a version of cd that uses spname? how would you install it?



7.3 File system: inodes

In this section we will discuss system calls that deal with the file system and
in particular with the information about files, such as size, dates,
permissions, and so on. These system calls allow you to get at all the
information we talked about in Chapter 2.

Let's dig into the inode itself. Part of the inode is described by a structure
called stat, defined in <sys/stat.h>:

        struct stat /* structure returned by stat */
        {
            dev_t st_dev;    /* device of indoe */
            ino_t st_ino;    /* indoe number */
            short st_mode;   /* mode bits */
            short st_nlink;  /* number of links to file */
            short st_uid;    /* owner's userid */
            short st_gid;    /* owner's group id */
            dev_t st_rdev;   /* for special file */
            off_t st_size;   /* file size in characters */
            time_t st_atime; /* time file last read */
            time_t st_mtime; /* time file last written or created */
            time_t st_ctime; /* time file or inode last changed */
        };


Most of the fields are explained by the comments. Types like dev_t and ino_t are
defined in <sys/types.h>, as discussed above. The st_mode entry contains a set
of flags describing the file; for convenience, the flag definitions are also
part of the file <sys/stat.h>:

        #define S_IFMT   0170000 /* type of file */
        #define S_IFDIR  0040000 /* directory */
        #define S_IFCHR  0020000 /* character special */
        #define S_IFBLK  0060000 /* block special */
        #define S_IFREG  0100000 /* regular */
        #define S_ISU1D  0004000 /* set user id on execution */
        #define S_ISGID  0002000 /* set group id on execution */
        #define S_ISVTX  0001000 /* save swapped text even after use */
        #define S_IREAD  0000400 /* read permission, owner */
        #define S_IWRITE 0000200 /* write permission, owner */
        #define S_IEXEC  0000100 /* execute/search permission, owner */

The inode for a file is accessed by a pair of system calls named stat and
fstat. stat takes a filename and returns inode information for that file (or -1
if there is an error). fstat does the same from a file descriptor for an open
file (not from a FILE pointer). That is,

        char *name;
        int fd;
        struct stat stbuf;

        stat(name, &stbuf);
        fstat(fd, &stbuf);

fills the structure stbuf with the inode information for the file name or file
descriptor fd.

With all these facts in hand, we can start to write some useful code. Let us
begin with a C version of checkmail, a program that watches your mailbox. If the
file grows larger, checkmail prints "You have mail" and rings the bell. (If the
file gets shorter, that is presumably because you have just read and deleted
some mail, and no message is wanted.) This is entirely adequate as a first step;
you can get fancier once this works.

        /* checkmail:  watch user's mailbox */
        #include <stdio.h>
        #include <sys/types.h>
        #include <sys/stat.h>
        char *progname;
        char *maildir = "/usr/spool/mail";  /* system dependent */

        main(argc, argv)
            int argc;
            char *argv[];
        {
            struct stat buf;
            char *name, *getlogin();
            int lastsize = 0;

            progname = argv[0];
            if ((name = getlogin()) == NULL)
                error("can't get login name", (char *) 0);
            if (chdir(maildir) == -1)
                error("can't cd to %s", maildir);
            for (;;) {
                if (stat(name, &buf) == -1) /* no mailbox */
                    buf.st_size = 0;
                if (buf.st_size > lastsize)
                    fprintf(stderr, "\nYou have mail\007\n");
                lastsize = buf.st_size;
                sleep(60);
            }
        }

The function getlogin(3) returns your login name, or NULL if it can't. checkmail
changes to the mail directory with the system call chdir, so that the subsequent
stat calls will not have to search each directory from the root to the mail
directory. You might have to change maildir to be correct on your system. We
wrote checkmail to keep trying even if there is no mailbox, since most versions
of mail remove the mailbox if it's empty.

We wrote this program in Chapter 5 in part to illustrate shell loops. That
version created several processes every time it looked at the mailbox, so it
might be more of a system load than you want. The C version is a single process
that does a stat on the file every minute. How much does it cost to have
checkmail running in the background all the time? We measured it at well under
one second per hour, which is low enough that it hardly matters.


sv: An illustration of error handling

We are next going to write a program called sv, similar to cp, that will copy a
set of files to a directory, but change each target file only if it does not
exist or is older than the source. "sv" stands for "save"; the idea is that sv
will not overwrite something that appears to be more up to date. sv uses more of
the information in the inode than checmail does.

The design we will use for sv is this:

        $ sv file1 file2 ... dir

copies file1 to dir/file1, file2 to dir/file2, etc., except that when a target
file is newer than its source file, no copy is made and a warning is printed. To
avoid making multiple copies of linked files, sv does not allow /'s in any of
the source filenames.

        /* sv:  save new files */
        #include <stdio.h>
        #include <sys/types.h>
        #include <sys/dir.h>
        #include <sys/stat.h>
        char *progname;

        main(argc, argv)
            int argc;
            char *argv[];
        {
            int i;
            struct stat stbuf;
            char *dir = argv[argc-1];

            progname = argv[0];
            if (argc <= 2)
                error("Usage: %s files... dir", progname);
            if (stat(dir, &stbuf) == -1)
                error("can't access directory %s", dir);
            if ((stbuf.st_mode & S_IFMT) != S_IFDIR)
                error("%s is not a directory", dir);
            for (i = 1; i < argc-1; i++)
                sv(argv[i], dir);
            exit(0);
        }

The times in the inode are in seconds-since-long-ago (0:00 GMT, January 1,
1970), so older files have smaller values in their st_mtime field.

        sv(file, dir)   /* save file in dir */
            char *file, *dir;
        {
            struct stat sti, sto;
            int fin, fout, n;
            char target[BUFSIZ], buf[BUFSIZ], *index();

            sprintf(target, "%s/%s", dir, file);
            if (index(file, '/') != NULL)  /* strchr() in some systems */
                error("won't handle /'s in %s", file);
            if (stat(file, &sti) == -1)
                error("can't stat %s", file);
            if (stat(target, &sto) == -1)   /* target not present */
                sto.st_mtime = 0;   /* so make it look old */
            if (sti.st_mtime < sto.st_mtime)    /* target is newer */
                fprintf(stderr, "%s: %s not copied\n",
                    progname, file);
            else if ((fin = open(file, 0)) == -1)
                error("can't open file %s", file);
            else if ((fout = creat(target, sti.st_mode)) == -1)
                error("can't create %s", target);
            else
                while ((n = read(fin, buf, sizeof buf)) > 0)
                    if (write(fout, buf, n) != n)
                        error("error writing %s", target);
            close(fin);
            close(fout);
        }

We used creat instead of the standard I/O functions so that sv can preserve the
mode of the input file. (Note that index and strchr are different names for the
same routine; check your manual under string(3) to see which name your system
uses.)

Although the sv program is rather specialized, it does indicate some important
ideas. Many programs are not "system programs" but may still use information
maintained by the operating system and accessed through system calls. For such
programs, it is crucial that the representation of the information appear only
in the standard header files like <stat.h> and <dir.h>, and that programs
include those files instead of embedding the actual declarations in
themselves. Such node is much more likely to be portable from one system to
another.

It is also worth noting that at least two thirds of the code in sv is error
checking. In the early stages of writing a program, it's tempting to skimp on
error handling, since it is a diversion from the main task. And once the program
"works," it's hard to be enthusiastic about going back to put in the checks that
convert a private program into one that works regardless of what happens.
------------------------------------page 219------------------------------------
sv isn't proof against all possible disasters --- it doesn't deal with
interrupts at awkward times, for instance --- but it's more careful than most
programs. To focus on just one point for a moment, consider the final write
statement. It is rare that a write fails, so many programs ignore the
possibility. But discs run out of space; users exceed quotas; communications
lines break. All of these cause write errors, and you are a lot better off if
you hear about them than if the program silently pretends that all is well.

The moral is that error checking is tedious but important. We have been cavalier
in most of the programs in this book because of space limitations and to focus
on more interesting topics. But for real, production programs, you can't afford
to ignore errors.

Exercise 7-10. Modify checkmail to identify the sender of the mail as part of
the "You have mail" message. Hint: sscanf, lseek.

Exercise 7-11. Modify checkmail so that it does not change to the mail directory
before it enters its loop. Does this have a measurable effect on its
performance? (Harder) Can you write a version of checkmail that only needs one
process to notify all users?

Exercise 7-12. Write a program watchfile that monitors a file and prints the
file from the beginning each time it changes. When would you use it?

Exercise 7-13. sv is quite rigid in its error handling. Modify it to continue
even if it can't process some file.

Exercise 7-14. Make sv recursive: if one of source files is a directory, that
directory and its files are processed in the same manner. Make cp
recursive. Discuss whether cp and sv ought to be the same program, so that cp -v
doesn't do the copy if the target is newer.

Exercise 7-15. Writ the program random:

        $ random filename

produces one line chosen at random from the file. Given a file people of names,
random can be used in a program called scapegoat, which is valuable for
allocating blame:

        $ cat scapegoat
        echo "it's all `random people`'s fault!"
        $ scapegoat
        It's all Ken's fault!
        $

Make sure that random is fair regardless of the distribution of line lengths.

Exercise 7-16. there's other information in the inode as well, in particular,
disc address where the file blocks are located. Examine the file <sys/ino.h>,
then write a program icat that will read specified by inode number and disc
device. (It will work only if the disc in question is readable, of course.)
Under what curcumstances is icat useful?



7.4 Processes

This section describes how to execute one program from within another. The
easiest way is with the standard library routine system, mentioned but censured
in Chapter 6. system takes one argument, a command line exactly as type at the
terminal (except for the newline at the end) and executes it in a sub-shell. If
the command line has to be built from pieces, the in-memory formatting
capabilities of sprintf may be useful. At the end of this section we will show a
safer version of system for use by interactive programs, but first we must
examine the pieces form which it is built.


Low-level process creation --- execlp and execvp

The most basic operation is to execute another program without returning, by
using the system call execlp. For example, to print the date as the last action
of a running program, use

        execlp ("date", "date", (char *) 0);

The first argument to execlp is the filename of the command; execlp extracts the
search path (i.e., $PATH) from your environment and does the same search as the
shell does. The second and subsequent arguments are the command name and the
arguments for the command; these become the argv array for the new program. The
end of the list is marked by a 0 argument. (Read exec(2) for insight on the
design of execlp.)

The execlp call overlays the existing program with the new one, runs that, then
exits. The original program gets control back only when there is an error, for
example if the file can't be found or is not executable:

        execlp ("date", "date", (char *) 0);
        fprintf(stderr, "Couldn't execute 'date'\n");
        exit(1);

A variant of execlp called execvp is useful when you don't know in advance how
many arguments there are going to be. The call is

        execvp (filename, argp);

where argp is an array of pointers to the arguments (such as argv); the last
pointer in the array must be NULL so execvp can tell where the list ends. As
with execlp, filename is the file in which the program is found, and argp is the
argv array for the new program; argp[0] is the program name.

Neither of these routines provides expansion of metacharacters like <, >, *,
quots, etc., in the argument list. If you want these, use execlp to invoke the
shell /bin/sh, which then does all the work. Construct a string commandline that
contains the complete command as it would have been typed at the terminal, then
say

        execlp ("/bin/sh/", "sh", "-c", commandline, (char *) 0);

The argument -c says to treat the next argument as the whole command line, not a
single argument.

As an illustration of exec, consider the program waitfile. The command

        $ waitfile filename [ command ]

periodically checks the file named. If it is unchanged since last time, the
command is executed. If no command is specified, the file is copied into the
standard output. We use waitfile no monitor the progress of troff, as in

        $ waitfile troff.out echo troff done &

The implementation of waitfile uses fstat to extract the time when the file was
last changed.

	/* waitfile:  wait until file stops changing */
	#include <stdio.h>
	#include <sys/types.h>
	#include <sys/stat.h>
	char *progname;

	main(argc, argv)
	    int argc;
	    char *argv[];
	{
	    int fd;
	    struct stat stbuf;
	    time_t old_time = 0;

	    progname = argv[0];
	    if (argc < 2)
		error("Usage: %s filename [cmd]", progname);
	    if ((fd = open(argv[1], 0)) == -1)
		error("can't open %s", argv[1]);
	    fstat(fd, &stbuf);
	    while (stbuf.st_mtime != old_time) {
		old_time = stbuf.st_mtime;
		sleep(60);
		fstat(fd, &stbuf);
	    }
	    if (argc == 2) {    /* copy file */
		execlp("cat", "cat", argv[1], (char *) 0);
		error("can't execute cat %s", argv[1]);
	    } else {            /* run process */
		execvp(argv[2], &argv[2]);
		error("can't execute %s", argv[2]);
	    }
	    exit(0);
	}

This illustrates both execlp and execvp.

We picked this design because it's useful, but other variations are
plausible. For example, waitfile could simply return after the file has stopped
changing.

Exercise 7-17. Modify watchfile (Exercise 7-12) so it has the same property as
waitfile, if there is no command, it copies the file; otherwise it does the
command. Could watchfile and waitfile share source code? Hint: argv[0].


Control of processes --- fork and wait

The next step is to regain control after running a program with execlp or
execvp. Since these routines simply overlay the new program on the old one, to
save the old one requires that it first be split into two copies; one of these
can be overlaid, while the other waits for the new, overlaying program to
finish. The splitting is done by a system call named fork:

        proc_id = fork();

splits the program into two copies, both of which continue to run. The only
difference between the two is the value returned by fork, the process-id. In one
of these processes (the child), process-id is zero. In the other (the parent),
proc_id is non-zero; it the process-id of the child. Thus the basic way to call,
and return from, another program is

        if (fork() == 0)
            execlp ("/bin/sh", "sh", "-c", commandline, (char *) 0);

And in fact, except for handling errors, this is sufficient. The fork makes two
copies of the program. In the child, the value returned by fork is zero, so it
calls execlp, which does the commandline and then dies. In the parent, fork
returns non-zero so it skips the execlp. (If there is any error, fork returns
-1.)

More often, the parent waits for the child to terminate before continuing
itself. This is done with the system call wait:

        int status;

        if(fork() == 0)
            execlp(...);        /* child */
        wait(&status);          /* parent */

This still doesn't handle any abnormal condition, such as a failure of the
execlp or fork, or the possibility that there might be more than one child
running simultaneously. (wait returns the process-id of the terminated child, if
you want to check it against the value returned by fork.) Finally, this fragment
doesn't deal with any funny behavior on the part of the child. Still, these
three lines are the heart of the standard system function.

The status returned by wait encodes in its low-order eight bits the system's
idea of the child's exit status; it is 0 for normal termination and non-zero to
indicate various kinds of problem. The next higher eight bits are taken from the
argument of the call to exit or return form main that caused termination of the
child process.

When a program is called by the shell, the three file descriptors 0, 1, and 2
are set up pointing at the right files, and all other file descriptors are
available for use. When this program calls another one, correct etiquette
suggests making sure that the same conditions hold. Neither fork nor exec calls
effect open files in any way; both parent and child have the same open files. If
the parent is buffering output that must come out before output from the child,
the parent must flush its buffers before the execlp. Conversely, if the parent
buffers an input stream, the child will lose any information that has been read
by the parent. Output can be flushed, but input cannot be put back. Both of
these considerations arise if the input or output is being done with the
standard I/O library discussed in Chapter 6, since it normally buffers both
input and output.

It is the inheritance of the file descriptors across an execlp that breaks
system: if the calling program does not have its standard input and output
connected to the terminal, neither will the command called by system. This may
be what is wanted; in an ed script, for example, the input for a command started
with an exclamation mark ! should probably come from the script. Even then ed
must read its input one character at a time to avoid input buffering problems.

For interactive programs like p, however, system should reconnect standard input
and output to the terminal. One way is to connect them to /dev/tty.

The system call dup(fd) duplicates the file descriptor fd on the lowest-numbered
unallocated file descriptor, returning a new descriptor that refers to the same
open file. This code connects the standard input of a program to a file:

        int fd;

        fd = open("file", 0);
        close(0);
        dup(fd);
        close(fd);

The close(0) deallocates file descriptor 0, the standard input, but as usual
doesn't affect the parent.

Here is our version of system for interactive programs; it uses progname for
error messages. You should ignore the parts of the function that deal with
signals; we will return to them in the next section.

        /*
         * Safer version of system for interactive programs
         */
        #include <signal.h>
        #include <stdio.h>

        system(s)   /* run command line s */
            char *s;
        {
            int status, pid, w, tty;
            int (*istat)(), (*qstat)();
            extern char *progname;

            fflush(stdout);
            tty = open("/dev/tty", 2);
            if (tty == -1) {
                fprintf(stderr, "%s: can't open /dev/tty\n", progname);
                return -1;
            }
            if ((pid = fork()) == 0) {
                close(0); dup(tty);
                close(1); dup(tty);
                close(2); dup(tty);
                close(tty);
                execlp("sh", "sh", "-c", s, (char *) 0);
                exit(127);
            }
            close(tty);
            istat = signal(SIGINT, SIG_IGN);
            qstat = signal(SIGQUIT, SIG_IGN);
            while ((w = wait(&status)) != pid && w != -1)
                ;
            if (w == -1)
                status = -1;
            signal(SIGINT, istat);
            signal(SIGQUIT, qstat);
            return status;
        }

Note that /dev/tty is opened with mode 2 --- read and write --- and then dup'ed
to form the standard input and output. This is actually how the system assembles
the standard input, output and error when you log in. Therefore, your standard
input is writable:

        $ echo hello 1>&0
        hello
        $

This means we could have dup'ed file descriptor 2 to reconnect the standard
input and output, but opening /dev/tty is cleaner and safer. Even this system
has potential problems: open files in the caller, such as tty in the routine
ttyin in p, will be passed to the child process.

The lesson here is not that you should use our version of system for all your
programs --- it would break a non-interactive ed, for example --- but that you
should understand how processes are manged and use the primitives correctly; the
meaning of "correctly" varies with the application, and may not agree with the
standard implementation of system.



7.5 Signals and interrupts

This section is concerned with how to deal gracefully with signals (like
interrupts) from the outside world, and with program faults. Program faults
arise mainly from illegal memory references, execution of peculiar instructions,
or floating point errors. The most common outside-world signals are interrupt,
which is sent when the DEL character is typed; quit, generated by the FS
character (ctl-\); hangup, caused by hanging up the phone; and terminate,
generated by the kill command. When one of these events occurs, the signal is
sent to all processes that were started form the same terminal; unless other
arrangements have been made, the signal terminates the process. For most
signals, a core image file is written for potential debugging. (See adb(1) and
sdb(1).)

The system call signal alters the default action. It has two arguments. The
first is a number that specifies the signal. The second is either the address of
a function, or a code which requests that the signal be ignored or be given the
default action. The file <signal.h> contains definitions for the various
arguments. Thus

        #include <signal.h>
        ...
        signal(SIGINT, SIG_IGN);

causes interrupts to be ignored, while

        signal(SIGINT, SIG_DEL);

restores the default action of process termination. In all cases, signal returns
the previous value of the signal. If the second argument to signal is the name
of a function (which must have been declared already in the same source file),
the function will be called when the signal occurs. Most commonly this facility
is used to allow the program to clean up unfinished business before terminating,
for example to delete a temporary file:

        #include <signal.h>
        char *tempfile = "temp.xxxxxx";

        main() {
            extern onintr();

            if(signal(SIGINT, SIG_IGN) != SIG_IGN)
                signal(SIGINT, onintr);
            mktemp(tempfile);

            /* Process ... */

            exit(0);
        }

        onintr() {      /* clean up if interrupted */
            unlink(tempfile);
            exit(1);
        }

Why the test and the double call to signal in main? Recall that signals are sent
to all processes started from a particular terminal. Accordingly, when a program
is to be run non-interactively (started by &), the shell arranges that the
program will ignore interrupts, so it won't be stopped by interrupts intended
for foreground processes. If this program began by announcing that all
interrupts were to be sent to the onintr routine regardless, that would undo the
shell's effort to protect it when run in the background.

The solution, shown above, is to test the state of interrupt handling, and to
continue to ignore interrupts if they are already being ignored. The code as
written depends on the fact that signal returns the previous state a particular
signal. If signals were already being ignored, the process should continue to
ignore then; otherwise, they should be caught.

A more sophisticated program may wish to intercept an interrupt and interpret it
as a request to stop what it is doing and return to its own command-processing
loop. Think of a text editor: interrupting a long printout should not cause it
to exit and lose the work already done. The code for this case can be written
like this:

        #include <signal.h>
        #include <setjmp.h>

        jmp_buf sjbuf;

        main()
        {
            int onintr();

            if(signal(SIGINT, SIG_IGN) != SIG_IGN)
                signal(SIGINT, onintr);
            setjmp(sjbuf);  /* save current stack position */

            for(;;) {
                /* main processing loop */
            }
            ...
        }

        onintr()    /* reset if interrupted */
        {                  
            signal(SIGINT, onintr);  /* reset for next interrupt */
            printf("\nInterrupt\n");
            longjmp(sjbuf, 0);       /* return to saved state */
        }

The file <setjmp.h> declares the type jmp_buf as an object in which the stack
position can be saved; sjbuf is declared to be such an object. The function
setjmp(3) saves a record of where the program was executing. The values of
variables are not saved. When an interrupt occurs, a call is forced to the
onintr routine, which can print a message, set flags, or whatever. longjmp takes
as argument an object stored into by setjmp, and restores control to the
location after the call to setjmp. So control (and the stack level) will pop
back to the place in the main routine where the main loop is entered.

Notice that the signal is set again in onintr after an interrupt occurs. This is
necessary: signals are automatically reset to their default action when they
occur.

Some programs that want to detect signals simply can't be stopped at an
arbitrary point, for example in the middle of updating a complicated data
structure. The solution is to have the interrupt routine set a flag and return
instead of calling exit or longjmp. Execution will continue at the exact point
it was interrupted, and the interrupt flag can be tested later.

There is one difficulty associated with this approach. Suppose the program is
reading the terminal when the interrupt is sent. The specified routine is duly
called; it sets its flag and returns. If it were really true, as we said above,
that execution resumes "at the exact point it was interrupted," the program
would continue reading the terminal until the user typed another line. This
behavior might well be confusing, since the user might not know that the program
is reading, and presumably would prefer to have the signal take effect
instantly. To resolve this difficulty, the system terminates the read, but with
an error status that indicates what happened: errno is set to EINTR, defined in
<errno.h>, to indicate an interrupted system call.

Thus programs that catch and resume execution after signals should be prepared
for "errors" caused by interrupted system calls. (The system calls to watch out
for are reads from a terminal, wait, and pause.) Such a program could use code
like the following when it reads the standard input:

	#include <errno.h>
	extern int errno;

	...

	if (read(0, &c, 1) <= 0)   /* EOF or interrupted */
	    if (errno == EINTR) {  /* EOF caused by interrupt */
		errno = 0;         /* reset for next time */
		...
	    } else {               /* true end of file */
		...
	    }

There is a final subtlety to keep in mind when signal-catching is combined with
execution of other programs. Suppose a program catches interrupts, and also
includes a method (like "!" in ed) whereby other programs can be executed. Then
the code would look something like this:

        if (fork() == 0)
            execlp(...);
        signal(SIGINT, SIG_IGN);        /* parent ignores interrupts */
        wait(&status);                  /* until child is done */
        signal(SIGINT, onintr);         /* restore interrupts */

Why is this? signals are sent to all your processes. Suppose the program you
call catches its own interrupts, as an editor does. If you interrupt the
subprogram, it will get the signal and return to its main loop, and probably
read you terminal. But the calling program will also pop out of its wait for the
subprogram and read you terminal. Having two processes reading your terminal is
very confusing, since in effect the system flips a coin to decide who should get
each line of input. The solution is to have the parent program ignore interrupts
until the child is done. This reasoning is reflected in the signal handling in
system:

        #include <signal.h>

        system(s)   /* run command line s */
            char *s;
        {
            int status, pid, w, tty;
            int (*istat)(), (*qstat)();

            ...
            if ((pid = fork()) == 0) {
                ...
                execlp("sh", "sh", "-c", s, (char *) 0);
                exit(127);
            }
            ...
            istat = signal(SIGINT, SIG_IGN);
            qstat = signal(SIGQUIT, SIG_IGN);
            while ((w = wait(&status)) != pid && w != -1)
                ;
            if (w == -1)
                status = -1;
            signal(SIGINT, istat);
            signal(SIGQUIT, qstat);
            return status;
        }

As an aside on declarations, the function signal obviously has a rather strange
second argument. It is in fact a pointer to a function delivering an integer,
and this is also the type of the signal routine itself. The two values SIG_IGN
and SIG_DEL have the right type, but are chosen so they coincide with no
possible actual functions. For the enthusiast, here is how they are defined for
the PDP-11 and VAX; the definitions should be sufficiently ugly to encourange
use of <signal.h>.

        #define SIG_DFL (int (*)())0
        #define SIG_IGN (int (*)())1


Alarms

The system all alarm(n) causes a signal SIGALRM to be sent to your process n
seconds later. The alarm signal can be used for making sure that something
happens within the proper amount of time; if the something happens, the alarm
signal can be turned off, but if it does not, the process can regain control by
catching the alarm signal.

To illustrate, here is a program called timeout that runs another command; if
that command has not finished by the specified time, it will be aborted when the
alarm goes off. For example, recall the watchfor command from Chapter 5. Rather
than having it run indefinitely, you might set a limit of an hour:

        $ timeout -3600 watchfor dmg &

The code in timeout illustrates almost everything we have talked about in the
past two sections. The child is created; the parent sets an alarm and then waits
for the child to finish. If the alarm arrives first, the child is killed. An
attempt is made to return the child's exit status.

        /* timeout:  set time limit on a process */
        #include <stdio.h>
        #include <signal.h>
        int pid;        /* child process id */
        char *progname;

        main(argc, argv)
            int argc;
            char *argv[];
        {
            int sec = 10, status, onalarm();

            progname = argv[0];
            if (argc > 1 && argv[1][0] == '-') {
                sec = atoi(&argv[1][1]);
                argc--;
                argv++;
            }
            if (argc < 2)
                error("Usage: %s [-10] command", progname);
            if ((pid=fork()) == 0) {
                execvp(argv[1], &argv[1]);
                error("couldn't start %s", argv[1]);
            }
            signal(SIGALRM, onalarm);
            alarm(sec);
            if (wait(&status) == -1 || (status & 0177) != 0)
                error("%s killed", argv[1]);
            exit((status >> 8) & 0377);
        }

        onalarm()   /* kill child when alarm arrives */
        {
            kill(pid, SIGKILL);
        }

Exercise 7-18. Can you infer how sleep is implemented? Hint: pause(2). Under
what circumstances, if any, could sleep and alarm interfere with each other?



History and bibliographic notes

There is no detailed description of the UNIX system implementation, in part
because the code is proprietary. Ken Thompson's paper "UNIX implementation"
(BSTJ, july, 1978) describes the basic ideas. Other papers that discuss related
topics are "The UNIX system --- a retrospective" in the same issue of BSTJ, and
"The evolution of the UNIX time-sharing system" (Symposium on Language Design
and Programming Methodology, Springer-Verlag Lecture Notes in Computer Science
#79, 1979.) Both are by Dennis Ritchie.

The program readslow was invented by Peter Weinberger, as a low-overhead way for
spectators to watch the progress of Belle, Ken Thompson and Joe Condon's chess
machine, during chess tournaments. Belle recorded the status of its game in a
file; onlookers polled the file with readslow so as not to steal too many
precious cycles from Belle. (The newest version of the Belle hardware does
little computing on its host machine, so the problem has gone away.)

Our inspiration for spname comes from Tom Duff. A paper by Ivor Durham, David
Lamb and James Saxe entitled "Spelling correction in user interfaces," CACM,
October, 1983, presents a somewhat different design for spelling correction, in
the context of a mail program.



				   Foot Notes

[1] Ken Thompson was once asked what he would do differently if he were
    redesigning the UNIX system. His reply: "I'd spell creat with an e."
