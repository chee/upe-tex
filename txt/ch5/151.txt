
        ...
        trap 'rm -f $new $old; exit 1' 1 2 15
        while :
        ...

The command sequence that forms the first argument to trap is like a subroutine
call that occurs immediately when the signal happens. When it finishes, the
program that was running will resume where it was unless the signal killed
it. There, the trap command sequence must explicitly invoke exit, or the shell
program will continue to execute after the interrupt. Also, the command sequence
will be read twice: once when the trap is set and once when it is
invoked. Therefore, the command sequence is best protected with single quotes,
so variables are evaluated only when the trap routines are executed. It makes no
difference in this case, but we will see one later in which it matters. By the
way, the -f option tells rm not to ask questions.

trap is sometimes useful interactively, most often to prevent a program from
being killed by the hangup signal generated by a broken phone connection:

        $ (trap '' 1; long-running-command) &
        2134
        $

The null command sequence means "ignore interrupts" in this process and its
children. The parentheses cause the trap and command to be run together in a
background sub-shell; without them, the trap would apply to the login shell as
well as to long-running-command.

The nohup(1) command is a short shell program to provide this service. Here is
the 7th Edition version, in its entirety:

        $ cat `which nohup`
        trap "" 1 15
        if test -t 2>&1
        then
                echo "Sending output to 'nohup.out'"
                exec nice -5 $* >>nohup.out 2>&1
        else
                exec nice -5 $* 2>&1
        fi
        $

test -t tests whether the standard output is a terminal, to see if the output
should be saved. The background program is run with nice to give it a lower
priority than interactive programs. (Notice that nohup doesn't set PATH. Should
it?)

The exec is just for efficiency; the command would run just as well without it,
exec is a shell built-in that replaces the process running this shell

